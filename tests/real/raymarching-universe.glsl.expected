uniform float gSceneId;

#define SCENE_MANDEL 0.0

#define SCENE_UNIVERSE 1.0

uniform float gCameraEyeX,gCameraEyeY,gCameraEyeZ,gCameraTargetX,gCameraTargetY,gCameraTargetZ,gCameraFov;struct Ray{vec3 origin;vec3 direction;};struct Camera{vec3 eye,target;vec3 forward,right,up;};
Camera camera;
Ray cameraShootRay(Camera c,vec2 uv)
{
  c.forward=normalize(c.target-c.eye);
  c.right=normalize(cross(c.forward,c.up));
  c.up=normalize(cross(c.right,c.forward));
  Ray r;
  r.origin=c.eye;
  r.direction=normalize(uv.x*c.right+uv.y*c.up+c.forward/tan(gCameraFov/360.*PI));
  return r;
}struct Intersection{bool hit;vec3 position;float distance;vec3 normal;vec2 uv;int count;vec3 baseColor;float roughness;float reflectance;float metallic;vec3 emission;vec3 color;};

#define calcNormal(p,dFunc,eps)normalize(vec2(eps,-eps).xyy*dFunc(p+vec2(eps,-eps).xyy)+vec2(eps,-eps).yyx*dFunc(p+vec2(eps,-eps).yyx)+vec2(eps,-eps).yxy*dFunc(p+vec2(eps,-eps).yxy)+vec2(eps,-eps).xxx*dFunc(p+vec2(eps,-eps).xxx))

float sdSphere(vec3 p,float r)
{
  return length(p)-r;
}
float sdCircle(vec2 p,float r)
{
  return length(p)-r;
}
mat2 rotate(float a)
{
  float c=cos(a),s=sin(a);
  return mat2(c,s,-s,c);
}
vec2 uvSphere(vec3 n)
{
  float u=.5+atan(n.z,n.x)/TAU,v=.5-asin(n.y)/PI;
  return vec2(u,v);
}
uniform float gPlanetsId;

#define PLANETS_MERCURY 0.0

#define PLANETS_MIX_A 1.0

#define PLANETS_KANETA 2.0

#define PLANETS_FMSCAT 3.0

#define PLANETS_MIX_B 4.0

#define PLANETS_EARTH 5.0

#define PLANETS_PAT_MAX 6

#define PLANETS_NUM_MAX 6

vec3 planetCenters=vec3[](vec3(0),vec3(0),vec3(0),vec3(0),vec3(0),vec3(0),vec3(0),vec3(0,0,100),vec3(0,0,200),vec3(0,0,300),vec3(0,0,400),vec3(0),vec3(0),vec3(0),vec3(0),vec3(0),vec3(0),vec3(0),vec3(0),vec3(0),vec3(0),vec3(0),vec3(0),vec3(0),vec3(-7,1,3),vec3(-3,-3.5,2),vec3(0),vec3(6,0,8),vec3(6,-3,2),vec3(6,5,-3),vec3(0),vec3(0),vec3(0),vec3(0),vec3(0),vec3(0));
int planetNums=int[](1,5,1,1,6,1);
float planetTextIds=float[](7.,8.,13.,14.,15.,0.);
float voronoi(vec3 p)
{
  vec3 ip=floor(p),fp=fract(p);
  vec2 r=vec2(2);
  for(int i=-1;i<=0;i++)
    for(int j=-1;j<=0;j++)
      for(int k=-1;k<=0;k++)
        {
          vec3 g=vec3(i,j,k),pp=fp+g+hash33(ip-g)*.6;
          float d=dot(pp,pp);
          if(d<r.x)
            r.y=r.x,r.x=d;
          else
             if(d<r.y)
              r.y=d;
        }
  return r.x;
}
float craters(vec3 p)
{
  float v=voronoi(p);
  return sin(sqrt(v)*TAU)*exp(-4.*v);
}
float hMercury(vec3 p)
{
  p.xz=rotate(beat*.05)*p.xz;
  float f=1.2,r=0.;
  for(int i=0;i<5;i++)
    r+=abs(craters(p*f))/f,f*=2.7;
  return r;
}
float dMercury(vec3 p)
{
  float d=sdSphere(p,1.);
  if(d<1.)
    d+=.075*hMercury(p);
  return d;
}
float hPlanetsMix(vec2 p,int id)
{
  p.y*=planetFbmParams[id].z;
  return fbm(p+planetFbmParams[id].w*fbm(p,4.*planetFbmParams[id].y),planetFbmParams[id].y);
}
vec3 pal(float t,vec3 a,vec3 b,vec3 c,vec3 d)
{
  return a+b*cos(TAU*(c*t+d));
}
float dPlanetsMix(vec3 p)
{
  float d=1e10;
  for(int i=0;i<planetNums[int(gPlanetsId)];i++)
    {
      int id=PLANETS_NUM_MAX*int(gPlanetsId)+i;
      vec3 center=planetCenters[id];
      float distance=max(0.,length(center-camera.eye)-60.);
      vec3 q=p-center;
      float s=sdSphere(q,exp(-.04*distance));
      if(s<1.)
        {
          vec2 uv=uvSphere(normalize(q));
          s-=planetFbmParams[id].x*hPlanetsMix(uv,id);
        }
      d=min(d,s);
    }
  return d;
}
void transformEarth(inout vec3 p)
{
  p.xz=rotate(.1*beat)*p.xz;
}
float hEarth(vec3 p,out vec2 uv)
{
  uv=uvSphere(normalize(p));
  return fbm(uv,10.);
}
float dEarth(vec3 p)
{
  transformEarth(p);
  float d=sdSphere(p,1.);
  if(d<1.)
    {
      vec2 uv;
      d-=.05*hEarth(p,uv);
    }
  return d;
}
float dPlanets(vec3 p)
{
  float d=1e10;
  if(gPlanetsId==PLANETS_MERCURY)
    d=min(d,dMercury(p));
  else
     if(gPlanetsId==PLANETS_MIX_A||gPlanetsId==PLANETS_MIX_B)
      d=min(d,dPlanetsMix(p));
    else
       if(gPlanetsId==PLANETS_EARTH)
        d=min(d,dEarth(p));
  return d;
}
float dGomi(vec3 p)
{
  float d=1.;
  vec3 g=vec3(floor(p/4.));
  p=mod(p,4.)-2.;
  vec3 rand=hash33(g);
  float rate=gPlanetsId!=PLANETS_EARTH?
    .08:
    .01;
  if(rand.x<rate)
    p-=rand-.5,d=sdSphere(p,.1*rand.y);
  if(d<.5)
    {
      vec2 uv=uvSphere(normalize(p));
      uv.x+=dot(rand,vec3(1));
      d-=remapTo(rand.z,.01,.08)*fbm(uv,5.);
    }
  return d;
}
float map(vec3 p)
{
  float d=dPlanets(p);
  d=min(d,dGomi(p));
  return d;
}
float logicoma(vec2 uv)
{
  float d=sdCircle(uv-vec2(0,-.5),.05);
  d=min(d,sdCircle(uv-vec2(-.5,.5),.05));
  d=min(d,sdCircle(uv-vec2(.5),.05));
  return d<0.?
    1.:
    0.;
}
float dMenger(vec3 z0,vec3 offset,float scale)
{
  vec4 z=vec4(z0,1);
  for(int n=0;n<3;n++)
    {
      z=abs(z);
      if(z.x<z.y)
        z.xy=z.yx;
      if(z.x<z.z)
        z.xz=z.zx;
      if(z.y<z.z)
        z.yz=z.zy;
      z*=scale;
      z.xyz-=offset*(scale-1.);
      if(z.z<-.5*offset.z*(scale-1.))
        z.z+=offset.z*(scale-1.);
    }
  return(length(max(abs(z.xyz)-vec3(1),0.))-.05)/z.w;
}
uniform vec3 gPlanetPalA,gPlanetPalB,gPlanetPalC;
uniform float gPlanetPalScale,gYosshinX,gYosshinY,gYosshinZ,gYosshinS,gYosshinS2;
float yosshin(vec3 p)
{
  p/=gYosshinS2;
  float d=dMenger(p,vec3(gYosshinX,gYosshinY,gYosshinZ),gYosshinS);
  return d<0.?
    1.:
    0.;
}
float prismbeings(vec2 uv)
{
  int i=int(uv.y*16.),j=int(uv.x+beat);
  return float(i>>int(beat*4.)%8&j&1);
}
uniform float gF0,gCameraLightIntensity;
float fresnelSchlick(float f0,float cosTheta)
{
  return f0+(1.-f0)*pow(1.-cosTheta,5.);
}
void intersectObjects(inout Intersection intersection,inout Ray ray)
{
  float d,distance=0.;
  vec3 p=ray.origin;
  float eps=.02;
  for(int i=0;i<200;i++)
    {
      d=map(p);
      distance+=d;
      p=ray.origin+distance*ray.direction;
      intersection.count=i;
      if(d<eps)
        break;
    }
  if(d<eps)
    {
      intersection.distance=distance;
      intersection.hit=true;
      intersection.position=p;
      intersection.normal=calcNormal(p,map,eps*.1);
      intersection.reflectance=0.;
      if(dPlanets(p)<eps)
        {
          if(gPlanetsId==PLANETS_MERCURY)
            intersection.baseColor=vec3(.7),intersection.roughness=.4,intersection.metallic=.01,intersection.emission=vec3(0);
          else
             if(gPlanetsId==PLANETS_MIX_A||gPlanetsId==PLANETS_MIX_B)
              {
                int id;
                vec2 uv;
                vec3 dir,offset;
                for(int i=0;i<planetNums[int(gPlanetsId)];i++)
                  {
                    vec3 center=planetCenters[PLANETS_NUM_MAX*int(gPlanetsId)+i];
                    offset=p-center;
                    float d=sdSphere(offset,1.);
                    if(abs(d)<eps*1e2)
                      {
                        id=PLANETS_NUM_MAX*int(gPlanetsId)+i;
                        dir=normalize(offset);
                        uv=uvSphere(dir);
                        break;
                      }
                  }
                float seed=float(id),h=hPlanetsMix(uv,id);
                vec3 rand=hash31(seed*gPlanetPalScale);
                intersection.baseColor=pal(h,gPlanetPalA,gPlanetPalB,gPlanetPalC,rand);
                intersection.roughness=.4;
                intersection.metallic=.8*rand.x;
                intersection.emission=vec3(0);
                if(id==int(PLANETS_MIX_B)*PLANETS_NUM_MAX)
                  intersection.baseColor=vec3(.05),intersection.emission=vec3(0),intersection.metallic=.9,intersection.reflectance=.9,intersection.roughness=.01;
                if(id==int(PLANETS_MIX_B)*PLANETS_NUM_MAX+1)
                  intersection.baseColor=vec3(0),intersection.emission=vec3(.3,.3,.5)*prismbeings(dir.xy),intersection.metallic=.9,intersection.reflectance=.9,intersection.roughness=.01;
                if(id==int(PLANETS_MIX_B)*PLANETS_NUM_MAX+4)
                  intersection.emission=vec3(.5,.5,.8)*logicoma(dir.xy);
                if(id==int(PLANETS_MIX_B)*PLANETS_NUM_MAX+2)
                  intersection.baseColor=vec3(.1),intersection.emission=vec3(.3,.3,.5)*yosshin(offset),intersection.metallic=.5;
              }
            else
               if(gPlanetsId==PLANETS_EARTH)
                {
                  transformEarth(p);
                  vec2 uv;
                  float h=hEarth(p,uv);
                  if(h>.67)
                    intersection.baseColor=mix(vec3(.03,.21,.14),vec3(240,204,170)/255.,remapFrom(h,.72,.99)),intersection.roughness=.4,intersection.metallic=.01,intersection.emission=vec3(0),intersection.emission=vec3(.07,.1,.07)*remapFrom(h,.67,.8);
                  else
                     intersection.baseColor=mix(vec3(.01,.03,.05),vec3(3,18,200)/255.,remapFrom(h,0.,.6)),intersection.roughness=.1,intersection.metallic=.134,intersection.emission=vec3(.1,.3,1)*remapFrom(h,.1,.67);
                  intersection.emission*=fresnelSchlick(.15,saturate(dot(-ray.direction,intersection.normal)));
                  float cloud=fbm(uv,15.);
                  intersection.baseColor=mix(intersection.baseColor,vec3(1.5),pow(cloud,4.));
                }
        }
      else
         intersection.baseColor=vec3(.7),intersection.roughness=.4,intersection.metallic=.01,intersection.emission=vec3(0);
    }
}
bool intersectAABB(inout Intersection intersection,inout Ray ray,vec3 lb,vec3 rt)
{
  vec3 dirfrac;
  dirfrac.x=1./ray.direction.x;
  dirfrac.y=1./ray.direction.y;
  dirfrac.z=1./ray.direction.z;
  float t1=(lb.x-ray.origin.x)*dirfrac.x,t2=(rt.x-ray.origin.x)*dirfrac.x,t3=(lb.y-ray.origin.y)*dirfrac.y,t4=(rt.y-ray.origin.y)*dirfrac.y,t5=(lb.z-ray.origin.z)*dirfrac.z,t6=(rt.z-ray.origin.z)*dirfrac.z,tmin=max(max(min(t1,t2),min(t3,t4)),min(t5,t6)),tmax=min(min(max(t1,t2),max(t3,t4)),max(t5,t6));
  if(tmin<=tmax&&0.<=tmin&&tmin<intersection.distance)
    {
      intersection.hit=true;
      intersection.position=ray.origin+ray.direction*(tmin>0.?
        tmin:
        tmax);
      intersection.distance=tmin;
      vec3 uvw=(intersection.position-lb)/(rt-lb);
      intersection.normal=vec3(0,0,1);
      intersection.uv=uvw.xy;
      return true;
    }
  return false;
}
void intersectScene(inout Intersection intersection,inout Ray ray)
{
  intersection.distance=1e10;
  intersectObjects(intersection,ray);
  if(beat<224.)
    {
      Intersection textIntersection=intersection;
      for(int i=0;i<planetNums[int(gPlanetsId)];i++)
        {
          vec3 center=planetCenters[PLANETS_NUM_MAX*int(gPlanetsId)+i];
          if(intersectAABB(textIntersection,ray,center+vec3(-2,1.5,0),center+vec3(2,2.5,.01)))
            {
              vec2 uv=(2.*textIntersection.uv-1.)*vec2(1,.25);
              float id=planetTextIds[int(gPlanetsId)]+float(i);
              vec3 t=texture(iTextTexture,textUv(uv,id,vec2(0),2.)).xyz;
              if(length(t)>.01)
                {
                  intersection.emission=.5*t;
                  intersection.hit=true;
                  break;
                }
            }
        }
    }
}

#define FLT_EPS 5.960464478e-8

float roughnessToExponent(float roughness)
{
  return clamp(2.*(1./(roughness*roughness))-2.,FLT_EPS,1./FLT_EPS);
}
vec3 evalPointLight(inout Intersection i,vec3 v,vec3 lp,vec3 radiance)
{
  vec3 n=i.normal,p=i.position,ref=mix(vec3(.04),i.baseColor,i.metallic),l=lp-p;
  float len=length(l);
  l/=len;
  vec3 h=normalize(l+v),diffuse=mix(1.-ref,vec3(0),i.metallic)*i.baseColor/PI;
  float m=roughnessToExponent(i.roughness);
  vec3 specular=ref*pow(max(0.,dot(n,h)),m)*(m+2.)/(8.*PI);
  return(diffuse+specular)*radiance*max(0.,dot(l,n))/(len*len);
}
vec3 evalDirectionalLight(inout Intersection i,vec3 v,vec3 lightDir,vec3 radiance)
{
  vec3 n=i.normal,ref=mix(vec3(.04),i.baseColor,i.metallic),l=lightDir,h=normalize(l+v),diffuse=mix(1.-ref,vec3(0),i.metallic)*i.baseColor/PI;
  float m=roughnessToExponent(i.roughness);
  vec3 specular=ref*pow(max(0.,dot(n,h)),m)*(m+2.)/(8.*PI);
  return(diffuse+specular)*radiance*max(0.,dot(l,n));
}
float fractal(vec3 p,int n)
{
  float strength=7.,accum=.25,prev=0.,tw=0.;
  for(int i=0;i<n;i++)
    {
      float mag=dot(p,p);
      p=abs(p)/mag+vec3(-.5,-.4,-1.5);
      float w=exp(-float(i)/7.);
      accum+=w*exp(-strength*pow(abs(mag-prev),2.2));
      tw+=w;
      prev=mag;
    }
  return max(0.,5.*accum/tw-.7);
}
vec3 skyboxUniverse(vec2 uv)
{
  vec3 col=vec3(1.2)*pow(fbm(uv*2e2),10.);
  float b=saturate(cos(TAU*beat/8.)),f=fractal(vec3(.2*uv+vec2(.3,.1),1.7+(beat-192.)*.001),28);
  col=mix(col,.3*vec3(1.3*f*f*f*b,1.8*f*f,f),f);
  f=fractal(vec3(.2*uv+vec2(.8,.2),2.7+(beat-192.)*.002),15);
  col=mix(col,.05*vec3(1.9*f*f*f,1.3*f*f,1.3*f*f),f*.5);
  return col;
}
void calcRadiance(inout Intersection intersection,inout Ray ray)
{
  intersection.hit=false;
  intersectScene(intersection,ray);
  if(intersection.hit)
    {
      intersection.color=intersection.emission;
      intersection.color+=evalPointLight(intersection,-ray.direction,camera.eye,gCameraLightIntensity*vec3(80,80,100));
      vec3 sunColor=vec3(1,.9,.8);
      intersection.color+=evalDirectionalLight(intersection,-ray.direction,vec3(-.486664263392288,.811107105653813,.324442842261525),sunColor);
    }
  else
    {
      float rdo=ray.direction.y+.6;
      vec2 uv=(ray.direction.xz+ray.direction.xz*2.5e5/rdo)*8e-6;
      intersection.color=skyboxUniverse(uv);
    }
}
uniform float gShockDistortion,gExplodeDistortion;
vec2 distortion(vec2 uv)
{
  float l=length(uv);
  uv+=-gShockDistortion*uv*cos(l);
  float explode=30.*gExplodeDistortion*exp(-2.*l);
  explode=mix(explode,2.*sin(l+10.*gExplodeDistortion),10.*gExplodeDistortion);
  uv+=explode*uv;
  return uv;
}
void mainImage(out vec4 fragColor,vec2 fragCoord)
{
  if(gSceneId!=SCENE_UNIVERSE||gPlanetsId==PLANETS_KANETA||gPlanetsId==PLANETS_FMSCAT)
    {
      vec2 uv=fragCoord/iResolution.xy;
      fragColor=texture(iPrevPass,uv);
      return;
    }
  vec2 uv=(fragCoord*2.-iResolution.xy)/min(iResolution.x,iResolution.y);
  uv=distortion(uv);
  camera.eye=vec3(gCameraEyeX,gCameraEyeY,gCameraEyeZ);
  camera.target=vec3(gCameraTargetX,gCameraTargetY,gCameraTargetZ);
  camera.up=vec3(0,1,0);
  Ray ray=cameraShootRay(camera,uv);
  vec3 color=vec3(0),reflection=vec3(1);
  Intersection intersection;
  for(int bounce=0;bounce<2;bounce++)
    {
      calcRadiance(intersection,ray);
      color+=reflection*intersection.color;
      if(!intersection.hit||intersection.reflectance==0.)
        break;
      reflection*=intersection.reflectance;
      ray.origin=intersection.position+intersection.normal*.1;
      vec3 l=reflect(ray.direction,intersection.normal);
      reflection*=fresnelSchlick(gF0,dot(l,intersection.normal));
      ray.direction=l;
    }
  fragColor=vec4(color,1);
}
