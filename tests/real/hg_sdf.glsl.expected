#define PI 3.14159265

#define TAU (2*PI)

#define PHI (sqrt(5)*0.5+0.5)

#define saturate(x)clamp(x,0,1)

float sgn(float x)
{
  return x<0?
    -1:
    1;
}
vec2 sgn(vec2 v)
{
  return vec2(v.x<0?
    -1:
    1,v.y<0?
    -1:
    1);
}
float square(float x)
{
  return x*x;
}
vec2 square(vec2 x)
{
  return x*x;
}
vec3 square(vec3 x)
{
  return x*x;
}
float lengthSqr(vec3 x)
{
  return dot(x,x);
}
float vmax(vec2 v)
{
  return max(v.x,v.y);
}
float vmax(vec3 v)
{
  return max(max(v.x,v.y),v.z);
}
float vmax(vec4 v)
{
  return max(max(v.x,v.y),max(v.z,v.w));
}
float vmin(vec2 v)
{
  return min(v.x,v.y);
}
float vmin(vec3 v)
{
  return min(min(v.x,v.y),v.z);
}
float vmin(vec4 v)
{
  return min(min(v.x,v.y),min(v.z,v.w));
}
float fSphere(vec3 p,float r)
{
  return length(p)-r;
}
float fPlane(vec3 p,vec3 n,float distanceFromOrigin)
{
  return dot(p,n)+distanceFromOrigin;
}
float fBoxCheap(vec3 p,vec3 b)
{
  return vmax(abs(p)-b);
}
float fBox(vec3 p,vec3 b)
{
  vec3 d=abs(p)-b;
  return length(max(d,vec3(0)))+vmax(min(d,vec3(0)));
}
float fBox2Cheap(vec2 p,vec2 b)
{
  return vmax(abs(p)-b);
}
float fBox2(vec2 p,vec2 b)
{
  vec2 d=abs(p)-b;
  return length(max(d,vec2(0)))+vmax(min(d,vec2(0)));
}
float fCorner(vec2 p)
{
  return length(max(p,vec2(0)))+vmax(min(p,vec2(0)));
}
float fBlob(vec3 p)
{
  p=abs(p);
  if(p.x<max(p.y,p.z))
    p=p.yzx;
  if(p.x<max(p.y,p.z))
    p=p.yzx;
  float b=max(max(max(dot(p,normalize(vec3(1))),dot(p.xz,normalize(vec2(PHI+1,1)))),dot(p.yx,normalize(vec2(1,PHI)))),dot(p.xz,normalize(vec2(1,PHI)))),l=length(p);
  return l-1.5-.2*(1.5/2)*cos(min(sqrt(1.01-b/l)*(PI/.25),PI));
}
float fCylinder(vec3 p,float r,float height)
{
  float d=length(p.xz)-r;
  d=max(d,abs(p.y)-height);
  return d;
}
float fCapsule(vec3 p,float r,float c)
{
  return mix(length(p.xz)-r,length(vec3(p.x,abs(p.y)-c,p.z))-r,step(c,abs(p.y)));
}
float fLineSegment(vec3 p,vec3 a,vec3 b)
{
  vec3 ab=b-a;
  float t=saturate(dot(p-a,ab)/dot(ab,ab));
  return length(ab*t+a-p);
}
float fCapsule(vec3 p,vec3 a,vec3 b,float r)
{
  return fLineSegment(p,a,b)-r;
}
float fTorus(vec3 p,float smallRadius,float largeRadius)
{
  return length(vec2(length(p.xz)-largeRadius,p.y))-smallRadius;
}
float fCircle(vec3 p,float r)
{
  float l=length(p.xz)-r;
  return length(vec2(p.y,l));
}
float fDisc(vec3 p,float r)
{
  float l=length(p.xz)-r;
  return l<0?
    abs(p.y):
    length(vec2(p.y,l));
}
float fHexagonCircumcircle(vec3 p,vec2 h)
{
  vec3 q=abs(p);
  return max(q.y-h.y,max(q.x*sqrt(3)*.5+q.z*.5,q.z)-h.x);
}
float fHexagonIncircle(vec3 p,vec2 h)
{
  return fHexagonCircumcircle(p,vec2(h.x*sqrt(3)*.5,h.y));
}
float fCone(vec3 p,float radius,float height)
{
  vec2 q=vec2(length(p.xz),p.y),tip=q-vec2(0,height),mantleDir=normalize(vec2(height,radius));
  float mantle=dot(tip,mantleDir),d=max(mantle,-q.y),projected=dot(tip,vec2(mantleDir.y,-mantleDir.x));
  if(q.y>height&&projected<0)
    d=max(d,length(tip));
  if(q.x>radius&&projected>length(vec2(height,radius)))
    d=max(d,length(q-vec2(radius,0)));
  return d;
}
const vec3 GDFVectors[19]=vec3[](normalize(vec3(1,0,0)),normalize(vec3(0,1,0)),normalize(vec3(0,0,1)),normalize(vec3(1)),normalize(vec3(-1,1,1)),normalize(vec3(1,-1,1)),normalize(vec3(1,1,-1)),normalize(vec3(0,1,PHI+1)),normalize(vec3(0,-1,PHI+1)),normalize(vec3(PHI+1,0,1)),normalize(vec3(-PHI-1,0,1)),normalize(vec3(1,PHI+1,0)),normalize(vec3(-1,PHI+1,0)),normalize(vec3(0,PHI,1)),normalize(vec3(0,-PHI,1)),normalize(vec3(1,0,PHI)),normalize(vec3(-1,0,PHI)),normalize(vec3(PHI,1,0)),normalize(vec3(-PHI,1,0)));
float fGDF(vec3 p,float r,float e,int begin,int end)
{
  float d=0;
  for(int i=begin;i<=end;++i)
    d+=pow(abs(dot(p,GDFVectors[i])),e);
  return pow(d,1/e)-r;
}
float fGDF(vec3 p,float r,int begin,int end)
{
  float d=0;
  for(int i=begin;i<=end;++i)
    d=max(d,abs(dot(p,GDFVectors[i])));
  return d-r;
}
float fOctahedron(vec3 p,float r,float e)
{
  return fGDF(p,r,e,3,6);
}
float fDodecahedron(vec3 p,float r,float e)
{
  return fGDF(p,r,e,13,18);
}
float fIcosahedron(vec3 p,float r,float e)
{
  return fGDF(p,r,e,3,12);
}
float fTruncatedOctahedron(vec3 p,float r,float e)
{
  return fGDF(p,r,e,0,6);
}
float fTruncatedIcosahedron(vec3 p,float r,float e)
{
  return fGDF(p,r,e,3,18);
}
float fOctahedron(vec3 p,float r)
{
  return fGDF(p,r,3,6);
}
float fDodecahedron(vec3 p,float r)
{
  return fGDF(p,r,13,18);
}
float fIcosahedron(vec3 p,float r)
{
  return fGDF(p,r,3,12);
}
float fTruncatedOctahedron(vec3 p,float r)
{
  return fGDF(p,r,0,6);
}
float fTruncatedIcosahedron(vec3 p,float r)
{
  return fGDF(p,r,3,18);
}
void pR(inout vec2 p,float a)
{
  p=cos(a)*p+sin(a)*vec2(p.y,-p.x);
}
void pR45(inout vec2 p)
{
  p=(p+vec2(p.y,-p.x))*sqrt(.5);
}
float pMod1(inout float p,float size)
{
  float halfsize=size*.5,c=floor((p+halfsize)/size);
  p=mod(p+halfsize,size)-halfsize;
  return c;
}
float pModMirror1(inout float p,float size)
{
  float halfsize=size*.5,c=floor((p+halfsize)/size);
  p=mod(p+halfsize,size)-halfsize;
  p*=mod(c,2.)*2-1;
  return c;
}
float pModSingle1(inout float p,float size)
{
  float halfsize=size*.5,c=floor((p+halfsize)/size);
  if(p>=0)
    p=mod(p+halfsize,size)-halfsize;
  return c;
}
float pModInterval1(inout float p,float size,float start,float stop)
{
  float halfsize=size*.5,c=floor((p+halfsize)/size);
  p=mod(p+halfsize,size)-halfsize;
  if(c>stop)
    p+=size*(c-stop),c=stop;
  if(c<start)
    p+=size*(c-start),c=start;
  return c;
}
float pModPolar(inout vec2 p,float repetitions)
{
  float angle=2*PI/repetitions,a=atan(p.y,p.x)+angle/2.,r=length(p),c=floor(a/angle);
  a=mod(a,angle)-angle/2.;
  p=vec2(cos(a),sin(a))*r;
  if(abs(c)>=repetitions/2)
    c=abs(c);
  return c;
}
vec2 pMod2(inout vec2 p,vec2 size)
{
  vec2 c=floor((p+size*.5)/size);
  p=mod(p+size*.5,size)-size*.5;
  return c;
}
vec2 pModMirror2(inout vec2 p,vec2 size)
{
  vec2 halfsize=size*.5,c=floor((p+halfsize)/size);
  p=mod(p+halfsize,size)-halfsize;
  p*=mod(c,vec2(2))*2-vec2(1);
  return c;
}
vec2 pModGrid2(inout vec2 p,vec2 size)
{
  vec2 c=floor((p+size*.5)/size);
  p=mod(p+size*.5,size)-size*.5;
  p*=mod(c,vec2(2))*2-vec2(1);
  p-=size/2;
  if(p.x>p.y)
    p.xy=p.yx;
  return floor(c/2);
}
vec3 pMod3(inout vec3 p,vec3 size)
{
  vec3 c=floor((p+size*.5)/size);
  p=mod(p+size*.5,size)-size*.5;
  return c;
}
float pMirror(inout float p,float dist)
{
  float s=sgn(p);
  p=abs(p)-dist;
  return s;
}
vec2 pMirrorOctant(inout vec2 p,vec2 dist)
{
  vec2 s=sgn(p);
  pMirror(p.x,dist.x);
  pMirror(p.y,dist.y);
  if(p.y>p.x)
    p.xy=p.yx;
  return s;
}
float pReflect(inout vec3 p,vec3 planeNormal,float offset)
{
  float t=dot(p,planeNormal)+offset;
  if(t<0)
    p-=2*t*planeNormal;
  return sgn(t);
}
float fOpUnionChamfer(float a,float b,float r)
{
  return min(min(a,b),(a-r+b)*sqrt(.5));
}
float fOpIntersectionChamfer(float a,float b,float r)
{
  return max(max(a,b),(a+r+b)*sqrt(.5));
}
float fOpDifferenceChamfer(float a,float b,float r)
{
  return fOpIntersectionChamfer(a,-b,r);
}
float fOpUnionRound(float a,float b,float r)
{
  vec2 u=max(vec2(r-a,r-b),vec2(0));
  return max(r,min(a,b))-length(u);
}
float fOpIntersectionRound(float a,float b,float r)
{
  vec2 u=max(vec2(r+a,r+b),vec2(0));
  return min(-r,max(a,b))+length(u);
}
float fOpDifferenceRound(float a,float b,float r)
{
  return fOpIntersectionRound(a,-b,r);
}
float fOpUnionColumns(float a,float b,float r,float n)
{
  if(a<r&&b<r)
    {
      vec2 p=vec2(a,b);
      float columnradius=r*sqrt(2)/((n-1)*2+sqrt(2));
      pR45(p);
      p.x-=sqrt(2)/2*r;
      p.x+=columnradius*sqrt(2);
      if(mod(n,2)==1)
        p.y+=columnradius;
      pMod1(p.y,columnradius*2);
      float result=length(p)-columnradius;
      result=min(result,p.x);
      result=min(result,a);
      return min(result,b);
    }
  return min(a,b);
}
float fOpDifferenceColumns(float a,float b,float r,float n)
{
  a=-a;
  float m=min(a,b);
  if(a<r&&b<r)
    {
      vec2 p=vec2(a,b);
      float columnradius=r*sqrt(2)/n/2.;
      columnradius=r*sqrt(2)/((n-1)*2+sqrt(2));
      pR45(p);
      p.y+=columnradius;
      p.x-=sqrt(2)/2*r;
      p.x+=-columnradius*sqrt(2)/2;
      if(mod(n,2)==1)
        p.y+=columnradius;
      pMod1(p.y,columnradius*2);
      float result=-length(p)+columnradius;
      result=max(result,p.x);
      result=min(result,a);
      return-min(result,b);
    }
  return-m;
}
float fOpIntersectionColumns(float a,float b,float r,float n)
{
  return fOpDifferenceColumns(a,-b,r,n);
}
float fOpUnionStairs(float a,float b,float r,float n)
{
  float s=r/n,u=b-r;
  return min(min(a,b),.5*(u+a+abs(mod(u-a+s,2*s)-s)));
}
float fOpIntersectionStairs(float a,float b,float r,float n)
{
  return-fOpUnionStairs(-a,-b,r,n);
}
float fOpDifferenceStairs(float a,float b,float r,float n)
{
  return-fOpUnionStairs(-a,b,r,n);
}
float fOpUnionSoft(float a,float b,float r)
{
  float e=max(r-abs(a-b),0);
  return min(a,b)-e*e*.25/r;
}
float fOpPipe(float a,float b,float r)
{
  return length(vec2(a,b))-r;
}
float fOpEngrave(float a,float b,float r)
{
  return max(a,(a+r-abs(b))*sqrt(.5));
}
float fOpGroove(float a,float b,float ra,float rb)
{
  return max(a,min(a+ra,rb-abs(b)));
}
float fOpTongue(float a,float b,float ra,float rb)
{
  return min(a,max(a-ra,abs(b)-rb));
}
